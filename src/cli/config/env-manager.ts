/**
 * @fileoverview Read/write ~/.wunderland/.env for API keys and secrets.
 * @module wunderland/cli/config/env-manager
 */

import { existsSync } from 'node:fs';
import { readFile, writeFile } from 'node:fs/promises';
import * as path from 'node:path';
import { getConfigDir, ensureConfigDir } from './config-manager.js';
import { ENV_FILE_NAME } from '../constants.js';

/** Resolve the .env file path. */
export function getEnvPath(configDirOverride?: string): string {
  return path.join(getConfigDir(configDirOverride), ENV_FILE_NAME);
}

/** Parse a .env file into a key-value map. */
export function parseEnvFile(contents: string): Record<string, string> {
  const out: Record<string, string> = {};
  for (const rawLine of contents.split('\n')) {
    const line = rawLine.trim();
    if (!line || line.startsWith('#')) continue;
    const idx = line.indexOf('=');
    if (idx === -1) continue;
    const key = line.slice(0, idx).trim();
    let val = line.slice(idx + 1).trim();
    // Strip surrounding quotes
    if ((val.startsWith('"') && val.endsWith('"')) || (val.startsWith("'") && val.endsWith("'"))) {
      val = val.slice(1, -1);
    }
    if (key) out[key] = val;
  }
  return out;
}

/** Serialize a key-value map to .env format. */
export function serializeEnvFile(env: Record<string, string>, header?: string): string {
  const lines: string[] = [];
  if (header) {
    lines.push(`# ${header}`);
    lines.push(`# Generated by wunderland setup â€” ${new Date().toISOString()}`);
    lines.push('');
  }
  for (const [key, val] of Object.entries(env)) {
    if (!key) continue;
    // Quote values with spaces or special chars
    const needsQuote = /[\s#"'\\]/.test(val);
    lines.push(`${key}=${needsQuote ? `"${val}"` : val}`);
  }
  lines.push(''); // trailing newline
  return lines.join('\n');
}

/** Load .env from ~/.wunderland/.env (does NOT set process.env). */
export async function loadEnv(configDirOverride?: string): Promise<Record<string, string>> {
  const filePath = getEnvPath(configDirOverride);
  if (!existsSync(filePath)) return {};

  try {
    const raw = await readFile(filePath, 'utf8');
    return parseEnvFile(raw);
  } catch {
    return {};
  }
}

/** Save .env to disk (creates dir if needed). File permissions: 0600. */
export async function saveEnv(
  env: Record<string, string>,
  configDirOverride?: string,
  header?: string,
): Promise<void> {
  await ensureConfigDir(configDirOverride);
  const filePath = getEnvPath(configDirOverride);
  const content = serializeEnvFile(env, header || 'Wunderland API Keys & Secrets');
  await writeFile(filePath, content, { encoding: 'utf8', mode: 0o600 });
}

/** Merge new keys into existing .env (preserves existing keys). */
export async function mergeEnv(
  newKeys: Record<string, string>,
  configDirOverride?: string,
): Promise<Record<string, string>> {
  const existing = await loadEnv(configDirOverride);
  const merged = { ...existing };
  for (const [key, val] of Object.entries(newKeys)) {
    if (val) merged[key] = val;
  }
  await saveEnv(merged, configDirOverride);
  return merged;
}

/**
 * Load .env files into process.env (same order as existing CLI).
 * Does not overwrite existing env vars.
 */
export async function loadDotEnvIntoProcess(...paths: string[]): Promise<void> {
  for (const filePath of paths) {
    if (!existsSync(filePath)) continue;
    try {
      const raw = await readFile(filePath, 'utf8');
      const parsed = parseEnvFile(raw);
      for (const [k, v] of Object.entries(parsed)) {
        if (!process.env[k]) process.env[k] = v;
      }
    } catch {
      // silently skip unreadable files
    }
  }
}
